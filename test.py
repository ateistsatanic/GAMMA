from pyrogram import Client, filters, idle
from pyrogram.types import (
    Message, InlineKeyboardMarkup, InlineKeyboardButton, 
    ReplyKeyboardMarkup, KeyboardButton, CallbackQuery
)
from pyrogram.enums import ParseMode, ChatType
import os
import json
import math
import random
import time
from os import sys
import concurrent.futures
from functools import partial, lru_cache
import asyncio
import aiofiles
import aiohttp
from aiohttp import ClientSession, TCPConnector
import logging
import psutil
from typing import Dict, List
import hashlib

import sys
import io

# –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ–¥–∏—Ä–æ–≤–∫–∏ –¥–ª—è Windows
if sys.platform == "win32":
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
token_log = '8390503590:AAGs_U7Bgi4YNqf1gN8fXwT8tKmvHFgxHMY'
chat_id_log = '-1002736899389'

with open('config/TOKEN.txt', 'r', encoding='utf-8') as f:
    API_TOKEN = f.readline().strip()

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
user_data_storage = {}
active_tasks = {}
thread_pool = concurrent.futures.ThreadPoolExecutor(max_workers=20)

app = Client("gamma_bot", bot_token=API_TOKEN, parse_mode=ParseMode.HTML)

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã
kb_rus = ReplyKeyboardMarkup(
    [
        [
            KeyboardButton(text='üåï –§–ª—É–¥–µ—Ä'),
            KeyboardButton(text='üåó –§–∞–π–ª—ã'),
            KeyboardButton(text='üåò –ê–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫'),
            KeyboardButton(text='üåî –ú—É–ª—å—Ç–∏'),
            KeyboardButton(text='üåë FAQ')
        ]
    ], resize_keyboard=True
)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è aiohttp —Å–µ—Å—Å–∏–∏
async def create_aiohttp_session():
    connector = TCPConnector(limit=100, limit_per_host=20, ttl_dns_cache=300)
    app.aiohttp_session = ClientSession(connector=connector, trust_env=True)
    print("‚úÖ aiohttp —Å–µ—Å—Å–∏—è —Å–æ–∑–¥–∞–Ω–∞")

async def close_aiohttp_session():
    if hasattr(app, 'aiohttp_session'):
        await app.aiohttp_session.close()
        print("‚úÖ aiohttp —Å–µ—Å—Å–∏—è –∑–∞–∫—Ä—ã—Ç–∞")

# –û–ë–†–ê–ë–û–¢–ß–ò–ö –°–¢–ê–†–¢–ê –° –§–û–¢–û
@app.on_message(filters.command("start"))
async def cmd_start(client: Client, message: Message):
    try:
        try:
            if os.path.exists('config/gamma.png'):
                await message.reply_photo(
                    'config/gamma.png',
                    caption='G.A.M.M.A v2.0.0 - –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è',
                    reply_markup=kb_rus
                )
            else:
                await message.reply(
                    'G.A.M.M.A v2.0.0 - –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è',
                    reply_markup=kb_rus
                )
        except Exception as photo_error:
            print(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ñ–æ—Ç–æ: {photo_error}")
            await message.reply(
                'G.A.M.M.A v2.0.0 - –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è',
                reply_markup=kb_rus
            )
    except Exception as e:
        await message.reply(f'–û—à–∏–±–∫–∞: {e}')

# –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
async def handle_main_menu(client: Client, message: Message):
    if message.text == 'üåï –§–ª—É–¥–µ—Ä':
        result = await chek_admin(message.from_user.id)
        if not result:
            await message.reply("‚ùå –ù–µ—Ç –ø—Ä–∞–≤")
            return
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üìã –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —á–∞—Ç–∞–º–∏", callback_data="flooder_chats")]
        ])
        await message.reply(
            "üåï –§–ª—É–¥–µ—Ä - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–ø–∞–º–æ–º\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=keyboard
        )
    
    elif message.text == 'üåó –§–∞–π–ª—ã':
        result = await chek_admin(message.from_user.id)
        if not result:
            await message.reply("‚ùå –ù–µ—Ç –ø—Ä–∞–≤")
            return
        
        config_dir = 'config'
        if not os.path.exists(config_dir):
            await message.reply("üìÅ –ü–∞–ø–∫–∞ config –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
            return
        
        files = [f for f in os.listdir(config_dir) if os.path.isfile(os.path.join(config_dir, f))]
        if not files:
            await message.reply("üìÅ –ü–∞–ø–∫–∞ –ø—É—Å—Ç–∞")
            return
        
        await message.reply(f"üìÇ –û—Ç–ø—Ä–∞–≤–∫–∞ {len(files)} —Ñ–∞–π–ª–æ–≤...")
        
        for filename in files:
            file_path = os.path.join(config_dir, filename)
            try:
                file_ext = os.path.splitext(filename)[1].lower()
                
                if file_ext in ['.jpg', '.jpeg', '.png', '.gif']:
                    await message.reply_photo(file_path, caption=f"üñºÔ∏è {filename}")
                elif file_ext in ['.mp4', '.avi', '.mov']:
                    await message.reply_video(file_path, caption=f"üé• {filename}")
                elif file_ext in ['.mp3', '.wav']:
                    await message.reply_audio(file_path, caption=f"üéµ {filename}")
                else:
                    await message.reply_document(file_path, caption=f"üìÑ {filename}")
                
                await asyncio.sleep(0.5)
            except Exception as e:
                await message.reply(f"‚ùå –û—à–∏–±–∫–∞ {filename}: {e}")
        
        await message.reply("‚úÖ –í—Å–µ —Ñ–∞–π–ª—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã!")
    
    elif message.text == 'üåë FAQ':
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üìñ –ì–∞–π–¥", url="https://teletype.in/@ksenod/6xaHYfronsG")],
            [
                InlineKeyboardButton("üëë –î–æ–±–∞–≤–∏—Ç—å –∞–¥–º–∏–Ω–∞", callback_data="add_admin"),
                InlineKeyboardButton("üóëÔ∏è –£–¥–∞–ª–∏—Ç—å –∞–¥–º–∏–Ω–∞", callback_data="remove_admin")
            ]
        ])
        
        await message.reply(
            "üìö FAQ - –ß–∞—Å—Ç–æ –∑–∞–¥–∞–≤–∞–µ–º—ã–µ –≤–æ–ø—Ä–æ—Å—ã\n\n"
            "–ó–¥–µ—Å—å –≤—ã –Ω–∞–π–¥–µ—Ç–µ –ø–æ–ª–µ–∑–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏ —Ä—É–∫–æ–≤–æ–¥—Å—Ç–≤–∞",
            reply_markup=keyboard
        )
    elif message.text == 'üåò –ê–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫':
         targets = load_respond_targets()
         targets_count = len(targets)
         
         keyboard = InlineKeyboardMarkup([
             [InlineKeyboardButton("üìã –î–æ–±–∞–≤–∏—Ç—å —Ü–µ–ª—å", callback_data="add_respond"),
              InlineKeyboardButton('‚ùå –£–¥–∞–ª–∏—Ç—å —Ü–µ–ª—å', callback_data='delete_respond')],
             [InlineKeyboardButton("üìä –ü–æ–∫–∞–∑–∞—Ç—å —Ü–µ–ª–∏", callback_data="show_respond_targets")]
         ])
         await message.reply(
             f"üåò –ê–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫ - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ\n\nüìä –ê–∫—Ç–∏–≤–Ω—ã—Ö —Ü–µ–ª–µ–π: {targets_count}\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
             reply_markup=keyboard
         )
    elif message.text == 'üåî –ú—É–ª—å—Ç–∏':
        result = await chek_admin(message.from_user.id)
        if not result:
            await message.reply("‚ùå –ù–µ—Ç –ø—Ä–∞–≤")
            return
        
        tokens = load_tokens()
        multi_tasks = load_multi_tasks()
        
        stats_text = f"üìä –ú—É–ª—å—Ç–∏-—Å–ø–∞–º:\n‚Ä¢ –¢–æ–∫–µ–Ω–æ–≤: {len(tokens)}\n‚Ä¢ –ó–∞–¥–∞—á: {len(multi_tasks)}"
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –º—É–ª—å—Ç–∏ —Å–ø–∞–º", callback_data="multi_add")],
            [InlineKeyboardButton("üóëÔ∏è –£–¥–∞–ª–∏—Ç—å –º—É–ª—å—Ç–∏ —Å–ø–∞–º", callback_data="multi_delete")],
            [InlineKeyboardButton("üîë –î–æ–±–∞–≤–∏—Ç—å —Ç–æ–∫–µ–Ω", callback_data="multi_add_token")],
            [InlineKeyboardButton("üìã –°–ø–∏—Å–æ–∫ —Ç–æ–∫–µ–Ω–æ–≤", callback_data="multi_list_tokens")]
        ])
        
        await message.reply(stats_text, reply_markup=keyboard)

@app.on_message(filters.group & filters.command("id"))
async def get_group_id(client: Client, message: Message):
    await message.reply(f"ID —ç—Ç–æ–π –≥—Ä—É–ø–ø—ã: <code>{message.chat.id}</code>")


@app.on_callback_query(filters.regex(r"^multi_textfile\|"))
async def multi_textfile_handler(client: Client, callback_query: CallbackQuery):
    if callback_query.from_user.id not in user_data_storage:
        await callback_query.answer("‚ùå –°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞")
        return
        
    text_file = callback_query.data.split('|', 1)[1]
    user_data = user_data_storage[callback_query.from_user.id]
    user_data['text_file'] = text_file
    user_data['state'] = "waiting_multi_media_file"
    user_data_storage[callback_query.from_user.id] = user_data
    
    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–¥–∏–∞ —Ñ–∞–π–ª—ã
    media_files = []
    if os.path.exists('config'):
        for file in os.listdir('config'):
            if file.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.mp4', '.avi', '.mov', '.mkv')):
                media_files.append(file)
    
    keyboard = [[InlineKeyboardButton("üö´ –ë–µ–∑ –º–µ–¥–∏–∞", callback_data=f"multi_media|none")]]
    
    for file in media_files:
        keyboard.append([InlineKeyboardButton(f"üìÅ {file}", callback_data=f"multi_media|{file}")])
    
    keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="multi_cancel")])
    
    await callback_query.message.edit_text("üé¨ –í—ã–±–µ—Ä–∏—Ç–µ –º–µ–¥–∏–∞ —Ñ–∞–π–ª:", reply_markup=InlineKeyboardMarkup(keyboard))
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^multi_media\|"))
async def multi_media_handler(client: Client, callback_query: CallbackQuery):
    if callback_query.from_user.id not in user_data_storage:
        await callback_query.answer("‚ùå –°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞")
        return
        
    media_data = callback_query.data.split('|', 1)[1]
    media_file = None if media_data == 'none' else media_data
    
    user_data = user_data_storage[callback_query.from_user.id]
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞–¥–∞—á—É
    multi_tasks = load_multi_tasks()
    chat_id = user_data['chat_id']
    
    multi_tasks[chat_id] = {
        'delay': user_data['delay'],
        'prefix': user_data['prefix'],
        'text_file': user_data['text_file'],
        'media_file': media_file,
        'active': True
    }
    
    save_multi_tasks(multi_tasks)
    await run_multi_task_optimized(chat_id, multi_tasks[chat_id])
    
    del user_data_storage[callback_query.from_user.id]
    
    # –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ —á–∞—Ç–∞ –¥–ª—è –∫—Ä–∞—Å–∏–≤–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
    chats_data = load_chats()
    chat_title = chats_data.get(chat_id, {}).get('title', f"–ß–∞—Ç {chat_id}")
    
    await callback_query.message.edit_text(
        f"‚úÖ –ú—É–ª—å—Ç–∏-—Å–ø–∞–º —Å–æ–∑–¥–∞–Ω –¥–ª—è {chat_title}!\n\n"
        f"–ó–∞–¥–µ—Ä–∂–∫–∞: {user_data['delay']}—Å–µ–∫\n"
        f"–ü—Ä–µ—Ñ–∏–∫—Å: {user_data['prefix'] or '–ù–µ—Ç'}\n"
        f"–§–∞–π–ª: {user_data['text_file']}\n"
        f"–ú–µ–¥–∏–∞: {media_file or '–ù–µ—Ç'}",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("‚óÄÔ∏è –í –º–µ–Ω—é", callback_data="multi_back_to_main")]
        ])
    )
    await callback_query.answer()

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—Ç–º–µ–Ω—ã
@app.on_callback_query(filters.regex(r"^multi_cancel$"))
async def multi_cancel_handler(client: Client, callback_query: CallbackQuery):
    if callback_query.from_user.id in user_data_storage:
        del user_data_storage[callback_query.from_user.id]
    await callback_query.message.edit_text("‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞")
    await callback_query.answer()

# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –º–µ–Ω—é
@app.on_callback_query(filters.regex(r"^multi_back_to_main$"))
async def multi_back_to_main_handler(client: Client, callback_query: CallbackQuery):
    tokens = load_tokens()
    multi_tasks = load_multi_tasks()
    
    stats_text = f"üìä –ú—É–ª—å—Ç–∏-—Å–ø–∞–º:\n‚Ä¢ –¢–æ–∫–µ–Ω–æ–≤: {len(tokens)}\n‚Ä¢ –ó–∞–¥–∞—á: {len(multi_tasks)}"
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –º—É–ª—å—Ç–∏ —Å–ø–∞–º", callback_data="multi_add")],
        [InlineKeyboardButton("üóëÔ∏è –£–¥–∞–ª–∏—Ç—å –º—É–ª—å—Ç–∏ —Å–ø–∞–º", callback_data="multi_delete")],
        [InlineKeyboardButton("üîë –î–æ–±–∞–≤–∏—Ç—å —Ç–æ–∫–µ–Ω", callback_data="multi_add_token")],
        [InlineKeyboardButton("üìã –°–ø–∏—Å–æ–∫ —Ç–æ–∫–µ–Ω–æ–≤", callback_data="multi_list_tokens")]
    ])
    
    await callback_query.message.edit_text(stats_text, reply_markup=keyboard)
    await callback_query.answer()


@app.on_callback_query(filters.regex(r"^multi_chat_select\|"))
async def multi_chat_select_handler(client: Client, callback_query: CallbackQuery):
    data_parts = callback_query.data.split('|')
    chat_id = data_parts[1]
    page = int(data_parts[2])
    
    chats_data = load_chats()
    chat_info = chats_data.get(chat_id)
    
    if not chat_info:
        await callback_query.answer("‚ùå –ß–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π —á–∞—Ç –∏ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º
    user_id = callback_query.from_user.id
    user_data_storage[user_id] = {
        'state': "waiting_multi_delay",
        'chat_id': chat_id,
        'page': page
    }
    
    await callback_query.message.edit_text(
        f"‚è∞ –í–≤–µ–¥–∏—Ç–µ –∑–∞–¥–µ—Ä–∂–∫—É –≤ —Å–µ–∫—É–Ω–¥–∞—Ö –¥–ª—è —á–∞—Ç–∞ {chat_info['title']}:",
        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="multi_cancel")]])
    )
    await callback_query.answer()

# –î–æ–±–∞–≤—å —ç—Ç–æ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –ø–æ–∫–∞–∑–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤ –≤ –º—É–ª—å—Ç–∏-—Å–ø–∞–º–µ
@app.on_callback_query(filters.regex(r"^waiting_multi_text_file$"))
async def show_multi_text_files(client: Client, callback_query: CallbackQuery):
    if callback_query.from_user.id not in user_data_storage:
        await callback_query.answer("‚ùå –°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞")
        return
    
    txt_files = []
    if os.path.exists('config'):
        for file in os.listdir('config'):
            if file.endswith('.txt'):
                txt_files.append(file)
    
    if not txt_files:
        await callback_query.answer("‚ùå –ù–µ—Ç txt —Ñ–∞–π–ª–æ–≤")
        return
    
    keyboard = []
    for file in txt_files:
        keyboard.append([InlineKeyboardButton(f"üìÑ {file}", callback_data=f"multi_textfile|{file}")])
    
    keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="multi_cancel")])
    
    await callback_query.message.edit_text("üìÅ –í—ã–±–µ—Ä–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª:", reply_markup=InlineKeyboardMarkup(keyboard))
    await callback_query.answer()


# –û–ë–†–ê–ë–û–¢–ß–ò–ö –ì–õ–ê–í–ù–û–ì–û –ú–ï–ù–Æ
@app.on_message(filters.private & filters.text & ~filters.command("start") & ~filters.command("chats"))
async def handle_main_menu_messages(client: Client, message: Message):
    user_id = message.from_user.id
    
    if message.text in ['üåï –§–ª—É–¥–µ—Ä', 'üåó –§–∞–π–ª—ã', 'üåò –ê–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫', 'üåî –ú—É–ª—å—Ç–∏', 'üåë FAQ']:
        await handle_main_menu(client, message)
        return
    
    if user_id in user_data_storage:
        await handle_all_text_messages(client, message)
    else:
        pass

@app.on_message(filters.private & filters.text & ~filters.me)
async def auto_responder_private_handler(client: Client, message: Message):
    try:
        targets = load_respond_targets()
        if not targets:
            return
            
        user_id_str = str(message.from_user.id)
        
        if user_id_str in targets:
            phrases_content = await async_cached_read('Phrases/messages.txt')
            if phrases_content:
                phrases = [line.strip() for line in phrases_content.split('\n') if line.strip()]
                if phrases:
                    response_text = random.choice(phrases)
                    asyncio.create_task(message.reply(response_text))
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –ª–∏—á–Ω–æ–≥–æ –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫–∞: {e}")

@app.on_callback_query(filters.regex(r"^multi_delete$"))
async def multi_delete_handler(client: Client, callback_query: CallbackQuery):
    multi_tasks = load_multi_tasks()
    
    if not multi_tasks:
        await callback_query.answer("‚ùå –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á –º—É–ª—å—Ç–∏-—Å–ø–∞–º–∞")
        return
    
    keyboard = []
    for chat_id, task_data in multi_tasks.items():
        chats_data = load_chats()
        chat_title = chats_data.get(chat_id, {}).get('title', f"–ß–∞—Ç {chat_id}")
        keyboard.append([InlineKeyboardButton(f"üóëÔ∏è {chat_title}", callback_data=f"multi_delete_confirm|{chat_id}")])
    
    keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="multi_back_to_main")])
    
    await callback_query.message.edit_text(
        "üóëÔ∏è –í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–¥–∞—á—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^multi_delete_confirm\|"))
async def multi_delete_confirm_handler(client: Client, callback_query: CallbackQuery):
    chat_id = callback_query.data.split('|')[1]
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚úÖ –î–∞, —É–¥–∞–ª–∏—Ç—å", callback_data=f"multi_delete_final|{chat_id}")],
        [InlineKeyboardButton("‚ùå –ù–µ—Ç, –æ—Ç–º–µ–Ω–∞", callback_data="multi_delete")]
    ])
    
    chats_data = load_chats()
    chat_title = chats_data.get(chat_id, {}).get('title', f"–ß–∞—Ç {chat_id}")
    
    await callback_query.message.edit_text(
        f"‚ö†Ô∏è –í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å –º—É–ª—å—Ç–∏-—Å–ø–∞–º –¥–ª—è —á–∞—Ç–∞ {chat_title}?",
        reply_markup=keyboard
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^multi_delete_final\|"))
async def multi_delete_final_handler(client: Client, callback_query: CallbackQuery):
    chat_id = callback_query.data.split('|')[1]
    
    multi_tasks = load_multi_tasks()
    
    if chat_id in multi_tasks:
        task_key = f"multi_{chat_id}"
        if task_key in active_tasks:
            active_tasks[task_key].cancel()
            del active_tasks[task_key]
        
        del multi_tasks[chat_id]
        save_multi_tasks(multi_tasks)
        await callback_query.answer("‚úÖ –ó–∞–¥–∞—á–∞ —É–¥–∞–ª–µ–Ω–∞")
    else:
        await callback_query.answer("‚ùå –ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
    
    callback_query.data = "multi_delete"
    await multi_delete_handler(client, callback_query)

# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
async def send_telegram_message(message_text: str):
    try:
        async with Client("logger", bot_token=token_log) as logger:
            await logger.send_message(chat_id_log, message_text)
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {e}")

async def chek_admin(user_id: int) -> bool:
    try:
        os.makedirs('config', exist_ok=True)
        admins_file = 'config/admins.json'
        
        if not os.path.exists(admins_file):
            with open(admins_file, 'w', encoding='utf-8') as f:
                json.dump({"admins": []}, f, ensure_ascii=False, indent=4)
            return False
        
        with open(admins_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        return str(user_id) in data.get("admins", [])
        
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–¥–º–∏–Ω–∞: {e}")
        return False

@lru_cache(maxsize=100)
def load_tokens() -> List[str]:
    os.makedirs('config', exist_ok=True)
    if os.path.exists('config/tokens.json'):
        try:
            with open('config/tokens.json', 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return []
    return []

def save_tokens(tokens: List[str]):
    os.makedirs('config', exist_ok=True)
    with open('config/tokens.json', 'w', encoding='utf-8') as f:
        json.dump(tokens, f, ensure_ascii=False, indent=4)

@lru_cache(maxsize=50)
def load_multi_tasks() -> Dict:
    os.makedirs('config', exist_ok=True)
    if os.path.exists('config/multi.json'):
        try:
            with open('config/multi.json', 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}

def save_multi_tasks(tasks: Dict):
    os.makedirs('config', exist_ok=True)
    with open('config/multi.json', 'w', encoding='utf-8') as f:
        json.dump(tasks, f, ensure_ascii=False, indent=4)

async def show_multi_chats_menu(message: Message, page: int = 0):
    chats_data = load_chats()
    if not chats_data:
        await message.reply("üìã –ù–µ—Ç —á–∞—Ç–æ–≤")
        return
    
    active_chats = {chat_id: info for chat_id, info in chats_data.items() if info.get('is_active', True)}
    if not active_chats:
        await message.reply("üìã –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —á–∞—Ç–æ–≤")
        return
    
    sorted_chats = sorted(active_chats.items(), key=lambda x: x[1]['title'])
    items_per_page = 5
    total_pages = math.ceil(len(sorted_chats) / items_per_page)
    
    if page >= total_pages: page = total_pages - 1
    if page < 0: page = 0
    
    start_idx = page * items_per_page
    end_idx = start_idx + items_per_page
    current_chats = sorted_chats[start_idx:end_idx]
    
    keyboard = []
    for chat_id, chat_info in current_chats:
        chat_title = chat_info['title'][:30] + "..." if len(chat_info['title']) > 30 else chat_info['title']
        keyboard.append([InlineKeyboardButton(chat_title, callback_data=f"multi_chat_select|{chat_id}|{page}")])
    
    pagination_buttons = []
    if page > 0:
        pagination_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"multi_chat_page|{page-1}"))
    if page < total_pages - 1:
        pagination_buttons.append(InlineKeyboardButton("–í–ø–µ—Ä–µ–¥ ‚û°Ô∏è", callback_data=f"multi_chat_page|{page+1}"))
    
    if pagination_buttons:
        keyboard.append(pagination_buttons)
    
    keyboard.append([InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data=f"multi_chat_refresh|{page}")])
    keyboard.append([InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="multi_back_to_main")])
    
    await message.reply(
        f"üìã –í—ã–±–µ—Ä–∏—Ç–µ —á–∞—Ç –¥–ª—è –º—É–ª—å—Ç–∏-—Å–ø–∞–º–∞ (–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page + 1}/{total_pages}):",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

async def send_multi_message_optimized(token: str, chat_id: str, text: str, media_path: str = None):
    try:
        url = f"https://api.telegram.org/bot{token}/"
        
        if media_path and os.path.exists(media_path):
            async with aiofiles.open(media_path, 'rb') as f:
                file_data = await f.read()
            
            form_data = aiohttp.FormData()
            
            if media_path.lower().endswith(('.jpg', '.jpeg', '.png', '.gif')):
                url += "sendPhoto"
                form_data.add_field('photo', file_data, filename=os.path.basename(media_path))
            elif media_path.lower().endswith(('.mp4', '.avi', '.mov', '.mkv')):
                url += "sendVideo"
                form_data.add_field('video', file_data, filename=os.path.basename(media_path))
            else:
                url += "sendDocument"
                form_data.add_field('document', file_data, filename=os.path.basename(media_path))
            
            form_data.add_field('chat_id', str(chat_id))
            form_data.add_field('caption', text)
            
            async with app.aiohttp_session.post(url, data=form_data) as response:
                return response.status == 200
                
        else:
            url += "sendMessage"
            data = {'chat_id': str(chat_id), 'text': text}
            
            async with app.aiohttp_session.post(url, json=data) as response:
                return response.status == 200
                
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {e}")
        return False

async def run_multi_task_optimized(chat_id: str, task_data: Dict):
    task_key = f"multi_{chat_id}"
    
    async def optimized_loop():
        error_count = 0
        max_errors = 10
        
        while True:
            try:
                multi_tasks = load_multi_tasks()
                current_task = multi_tasks.get(chat_id)
                
                if not current_task or not current_task.get('active', True):
                    break
                
                if error_count > 0:
                    wait_time = min(300, 2 ** error_count)
                    await asyncio.sleep(wait_time)
                
                tokens = load_tokens()
                if not tokens:
                    await asyncio.sleep(60)
                    continue
                
                text_file_path = f"config/{task_data['text_file']}"
                if os.path.exists(text_file_path):
                    async with aiofiles.open(text_file_path, 'r', encoding='utf-8') as f:
                        content = await f.read()
                        messages = [msg.strip() for msg in content.split('\n') if msg.strip()]
                else:
                    await asyncio.sleep(60)
                    continue
                
                message_text = task_data['prefix'] + ' ' + random.choice(messages) if task_data['prefix'] else random.choice(messages)
                media_file_path = f"config/{task_data['media_file']}" if task_data['media_file'] else None
                
                send_tasks = []
                for token in tokens:
                    send_task = send_multi_message_optimized(token, chat_id, message_text, media_file_path)
                    send_tasks.append(send_task)
                
                results = []
                for i in range(0, len(send_tasks), 5):
                    batch = send_tasks[i:i+5]
                    batch_results = await asyncio.gather(*batch, return_exceptions=True)
                    results.extend(batch_results)
                    await asyncio.sleep(0.1)
                
                success_count = sum(1 for r in results if r is True)
                if success_count > 0:
                    error_count = max(0, error_count - 1)
                
                print(f"üì§ –£—Å–ø–µ—à–Ω–æ: {success_count}/{len(tokens)}")
                
                await asyncio.sleep(task_data['delay'])
                
            except asyncio.CancelledError:
                raise
            except Exception as e:
                error_count += 1
                print(f"‚ùå –û—à–∏–±–∫–∞ –≤ –∑–∞–¥–∞—á–µ {chat_id}: {e}")
                if error_count >= max_errors:
                    print(f"üî¥ –ó–∞–¥–∞—á–∞ {chat_id} –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –∏–∑-–∑–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–∞ –æ—à–∏–±–æ–∫")
                    break
    
    active_tasks[task_key] = asyncio.create_task(optimized_loop())
    print(f"‚úÖ –ú—É–ª—å—Ç–∏-–∑–∞–¥–∞—á–∞ –∑–∞–ø—É—â–µ–Ω–∞: {task_key}")

@lru_cache(maxsize=50)
def load_respond_targets() -> Dict:
    try:
        os.makedirs('config', exist_ok=True)
        if os.path.exists('config/resp.json'):
            with open('config/resp.json', 'r', encoding='utf-8') as f:
                data = f.read().strip()
                if not data:
                    return {}
                return json.loads(data)
        return {}
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ resp.json: {e}")
        return {}

def save_respond_targets(targets: Dict):
    os.makedirs('config', exist_ok=True)
    with open('config/resp.json', 'w', encoding='utf-8') as f:
        json.dump(targets, f, ensure_ascii=False, indent=4)

@app.on_callback_query(filters.regex(r"^add_respond$"))
async def add_respond_handler(client: Client, callback_query: CallbackQuery):
    user_id = callback_query.from_user.id
    
    user_data_storage[user_id] = {
        'state': "waiting_add_respond_target"
    }
    
    await callback_query.message.edit_text(
        "üìù –í–≤–µ–¥–∏—Ç–µ ID —á–∞—Ç–∞ –∏–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫:\n\n"
        "–§–æ—Ä–º–∞—Ç: <code>ID_—á–∞—Ç–∞</code> –∏–ª–∏ <code>ID_–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è</code>",
        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_respond")]])
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^delete_respond$"))
async def delete_respond_handler(client: Client, callback_query: CallbackQuery):
    user_id = callback_query.from_user.id
    
    user_data_storage[user_id] = {
        'state': "waiting_delete_respond_target"
    }
    
    await callback_query.message.edit_text(
        "üìù –í–≤–µ–¥–∏—Ç–µ ID —á–∞—Ç–∞ –∏–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∏–∑ –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫–∞:",
        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_respond")]])
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^cancel_respond$"))
async def cancel_respond_handler(client: Client, callback_query: CallbackQuery):
    if callback_query.from_user.id in user_data_storage:
        del user_data_storage[callback_query.from_user.id]
    await callback_query.message.edit_text("‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞")
    await callback_query.answer()

@lru_cache(maxsize=50)
def load_flooder_tasks() -> Dict:
    os.makedirs('config', exist_ok=True)
    if os.path.exists('config/flooder.json'):
        try:
            with open('config/flooder.json', 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}


# –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –†–ï–î–ê–ö–¢–ò–†–û–í–ê–ù–ò–Ø –ó–ê–î–ê–ß
@app.on_callback_query(filters.regex(r"^edit_tasks\|"))
async def edit_tasks_handler(client: Client, callback_query: CallbackQuery):
    data_parts = callback_query.data.split('|')
    
    if len(data_parts) < 3:
        await callback_query.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö")
        return
    
    chat_id = data_parts[1]
    page = int(data_parts[2])
    
    flooder_tasks = load_flooder_tasks()
    chat_tasks = flooder_tasks.get(chat_id, {})
    
    if not chat_tasks:
        await callback_query.answer("‚ùå –ù–µ—Ç –∑–∞–¥–∞—á –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è")
        return
    
    keyboard = []
    for task_id, task_data in chat_tasks.items():
        status = "‚úÖ" if task_data.get('active', True) else "‚ùå"
        keyboard.append([
            InlineKeyboardButton(
                f"{status} {task_id} ({task_data['delay']}—Å–µ–∫)",
                callback_data=f"task_manage|{chat_id}|{task_id}|{page}"
            )
        ])
    
    keyboard.append([InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=f"chat_select|{chat_id}|{page}")])
    
    await callback_query.message.edit_text(
        "‚öôÔ∏è –í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–¥–∞—á—É –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^task_manage\|"))
async def task_manage_handler(client: Client, callback_query: CallbackQuery):
    data_parts = callback_query.data.split('|')
    if len(data_parts) < 4:
        await callback_query.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö")
        return
    
    chat_id = data_parts[1]
    task_id = data_parts[2]
    page = int(data_parts[3])

    flooder_tasks = load_flooder_tasks()
    task_data = flooder_tasks.get(chat_id, {}).get(task_id)

    if not task_data:
        await callback_query.answer("‚ùå –ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
        return

    status = "‚úÖ –í–ö–õ" if task_data.get('active', True) else "‚ùå –í–´–ö–õ"

    keyboard = [
        [InlineKeyboardButton(f"üîÑ –°—Ç–∞—Ç—É—Å: {status}", callback_data=f"task_toggle|{chat_id}|{task_id}|{page}")],
        [InlineKeyboardButton("‚è∞ –ò–∑–º–µ–Ω–∏—Ç—å –∑–∞–¥–µ—Ä–∂–∫—É", callback_data=f"task_delay|{chat_id}|{task_id}|{page}")],
        [InlineKeyboardButton("üìù –ò–∑–º–µ–Ω–∏—Ç—å –ø—Ä–µ—Ñ–∏–∫—Å", callback_data=f"task_prefix|{chat_id}|{task_id}|{page}")],
        [InlineKeyboardButton("üìÑ –ò–∑–º–µ–Ω–∏—Ç—å —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª", callback_data=f"task_textfile|{chat_id}|{task_id}|{page}")],
        [InlineKeyboardButton("üé¨ –ò–∑–º–µ–Ω–∏—Ç—å –º–µ–¥–∏–∞ —Ñ–∞–π–ª", callback_data=f"task_media|{chat_id}|{task_id}|{page}")],
        [InlineKeyboardButton("üóëÔ∏è –£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É", callback_data=f"task_delete|{chat_id}|{task_id}|{page}")],
        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=f"edit_tasks|{chat_id}|{page}")]
    ]

    await callback_query.message.edit_text(
        f"‚öôÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–µ–π: {task_id}\n\n"
        f"üìä –°—Ç–∞—Ç—É—Å: {status}\n"
        f"‚è∞ –ó–∞–¥–µ—Ä–∂–∫–∞: {task_data['delay']} —Å–µ–∫\n"
        f"üìù –ü—Ä–µ—Ñ–∏–∫—Å: {task_data['prefix'] or '–ù–µ—Ç'}\n"
        f"üìÑ –§–∞–π–ª: {task_data['text_file']}\n"
        f"üé¨ –ú–µ–¥–∏–∞: {task_data['media_file'] or '–ù–µ—Ç'}",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^task_toggle\|"))
async def task_toggle_handler(client: Client, callback_query: CallbackQuery):
    data_parts = callback_query.data.split('|')
    chat_id = data_parts[1]
    task_id = data_parts[2]
    page = int(data_parts[3])
    
    flooder_tasks = load_flooder_tasks()
    if chat_id in flooder_tasks and task_id in flooder_tasks[chat_id]:
        if flooder_tasks[chat_id][task_id].get('active', True):
            await stop_flooder_task(chat_id, task_id)
            flooder_tasks[chat_id][task_id]['active'] = False
        else:
            flooder_tasks[chat_id][task_id]['active'] = True
            await run_flooder_task(chat_id, task_id, flooder_tasks[chat_id][task_id])
        
        save_flooder_tasks(flooder_tasks)
        await callback_query.answer("‚úÖ –°—Ç–∞—Ç—É—Å –∏–∑–º–µ–Ω–µ–Ω")
        
        callback_query.data = f"task_manage|{chat_id}|{task_id}|{page}"
        await task_manage_handler(client, callback_query)
    else:
        await callback_query.answer("‚ùå –ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

@app.on_callback_query(filters.regex(r"^task_delay\|"))
async def task_delay_edit_handler(client: Client, callback_query: CallbackQuery):
    data_parts = callback_query.data.split('|')
    chat_id = data_parts[1]
    task_id = data_parts[2]
    page = int(data_parts[3])
    
    user_data_storage[callback_query.from_user.id] = {
        'state': "waiting_edit_delay",
        'chat_id': chat_id,
        'task_id': task_id,
        'page': page
    }
    
    await callback_query.message.edit_text(
        "‚è∞ –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—É—é –∑–∞–¥–µ—Ä–∂–∫—É –≤ —Å–µ–∫—É–Ω–¥–∞—Ö:",
        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data=f"task_manage|{chat_id}|{task_id}|{page}")]])
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^task_prefix\|"))
async def task_prefix_edit_handler(client: Client, callback_query: CallbackQuery):
    data_parts = callback_query.data.split('|')
    chat_id = data_parts[1]
    task_id = data_parts[2]
    page = int(data_parts[3])
    
    user_data_storage[callback_query.from_user.id] = {
        'state': "waiting_edit_prefix",
        'chat_id': chat_id,
        'task_id': task_id,
        'page': page
    }
    
    await callback_query.message.edit_text(
        "üìù –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π –ø—Ä–µ—Ñ–∏–∫—Å (–∏–ª–∏ '–ù–µ—Ç'):",
        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data=f"task_manage|{chat_id}|{task_id}|{page}")]])
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^task_textfile\|"))
async def task_textfile_handler(client: Client, callback_query: CallbackQuery):
    data_parts = callback_query.data.split('|')
    chat_id = data_parts[1]
    task_id = data_parts[2]
    page = int(data_parts[3])
    
    txt_files = []
    if os.path.exists('config'):
        for file in os.listdir('config'):
            if file.endswith('.txt'):
                txt_files.append(file)
    
    if not txt_files:
        await callback_query.answer("‚ùå –ù–µ—Ç txt —Ñ–∞–π–ª–æ–≤")
        return
    
    keyboard = []
    for file in txt_files:
        keyboard.append([InlineKeyboardButton(f"üìÑ {file}", callback_data=f"edit_textfile|{chat_id}|{task_id}|{page}|{file}")])
    
    keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data=f"task_manage|{chat_id}|{task_id}|{page}")])
    
    await callback_query.message.edit_text(
        "üìÅ –í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^edit_textfile\|"))
async def edit_textfile_handler(client: Client, callback_query: CallbackQuery):
    data_parts = callback_query.data.split('|')
    chat_id = data_parts[1]
    task_id = data_parts[2]
    page = int(data_parts[3])
    text_file = data_parts[4]
    
    flooder_tasks = load_flooder_tasks()
    if chat_id in flooder_tasks and task_id in flooder_tasks[chat_id]:
        await stop_flooder_task(chat_id, task_id)
        
        flooder_tasks[chat_id][task_id]['text_file'] = text_file
        save_flooder_tasks(flooder_tasks)
        
        if flooder_tasks[chat_id][task_id].get('active', True):
            await run_flooder_task(chat_id, task_id, flooder_tasks[chat_id][task_id])
        
        await callback_query.answer("‚úÖ –¢–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª –∏–∑–º–µ–Ω–µ–Ω")
        
        callback_query.data = f"task_manage|{chat_id}|{task_id}|{page}"
        await task_manage_handler(client, callback_query)
    else:
        await callback_query.answer("‚ùå –ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

@app.on_callback_query(filters.regex(r"^task_media\|"))
async def task_media_handler(client: Client, callback_query: CallbackQuery):
    data_parts = callback_query.data.split('|')
    chat_id = data_parts[1]
    task_id = data_parts[2]
    page = int(data_parts[3])
    
    media_files = []
    if os.path.exists('config'):
        for file in os.listdir('config'):
            if file.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.mp4', '.avi', '.mov', '.mkv')):
                media_files.append(file)
    
    keyboard = [[InlineKeyboardButton("üö´ –ë–µ–∑ –º–µ–¥–∏–∞", callback_data=f"edit_media|{chat_id}|{task_id}|{page}|none")]]
    
    for file in media_files:
        keyboard.append([InlineKeyboardButton(f"üìÅ {file}", callback_data=f"edit_media|{chat_id}|{task_id}|{page}|{file}")])
    
    keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data=f"task_manage|{chat_id}|{task_id}|{page}")])
    
    await callback_query.message.edit_text(
        "üé¨ –í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤—ã–π –º–µ–¥–∏–∞ —Ñ–∞–π–ª:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^edit_media\|"))
async def edit_media_handler(client: Client, callback_query: CallbackQuery):
    data_parts = callback_query.data.split('|')
    chat_id = data_parts[1]
    task_id = data_parts[2]
    page = int(data_parts[3])
    media_file = data_parts[4]
    
    if media_file == 'none':
        media_file = None
    
    flooder_tasks = load_flooder_tasks()
    if chat_id in flooder_tasks and task_id in flooder_tasks[chat_id]:
        await stop_flooder_task(chat_id, task_id)
        
        flooder_tasks[chat_id][task_id]['media_file'] = media_file
        save_flooder_tasks(flooder_tasks)
        
        if flooder_tasks[chat_id][task_id].get('active', True):
            await run_flooder_task(chat_id, task_id, flooder_tasks[chat_id][task_id])
        
        await callback_query.answer("‚úÖ –ú–µ–¥–∏–∞ —Ñ–∞–π–ª –∏–∑–º–µ–Ω–µ–Ω")
        
        callback_query.data = f"task_manage|{chat_id}|{task_id}|{page}"
        await task_manage_handler(client, callback_query)
    else:
        await callback_query.answer("‚ùå –ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

@app.on_callback_query(filters.regex(r"^task_delete\|"))
async def task_delete_handler(client: Client, callback_query: CallbackQuery):
    data_parts = callback_query.data.split('|')
    chat_id = data_parts[1]
    task_id = data_parts[2]
    page = int(data_parts[3])
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚úÖ –î–∞, —É–¥–∞–ª–∏—Ç—å", callback_data=f"confirm_delete|{chat_id}|{task_id}|{page}")],
        [InlineKeyboardButton("‚ùå –ù–µ—Ç, –æ—Ç–º–µ–Ω–∞", callback_data=f"task_manage|{chat_id}|{task_id}|{page}")]
    ])
    
    await callback_query.message.edit_text(
        "‚ö†Ô∏è –í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —ç—Ç—É –∑–∞–¥–∞—á—É?",
        reply_markup=keyboard
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^confirm_delete\|"))
async def confirm_delete_handler(client: Client, callback_query: CallbackQuery):
    data_parts = callback_query.data.split('|')
    chat_id = data_parts[1]
    task_id = data_parts[2]
    page = int(data_parts[3])
    
    flooder_tasks = load_flooder_tasks()
    if chat_id in flooder_tasks and task_id in flooder_tasks[chat_id]:
        await stop_flooder_task(chat_id, task_id)
        
        del flooder_tasks[chat_id][task_id]
        if not flooder_tasks[chat_id]:
            del flooder_tasks[chat_id]
        save_flooder_tasks(flooder_tasks)
        await callback_query.answer("‚úÖ –ó–∞–¥–∞—á–∞ —É–¥–∞–ª–µ–Ω–∞")
        
        callback_query.data = f"edit_tasks|{chat_id}|{page}"
        await edit_tasks_handler(client, callback_query)
    else:
        await callback_query.answer("‚ùå –ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")


def save_flooder_tasks(tasks: Dict):
    os.makedirs('config', exist_ok=True)
    with open('config/flooder.json', 'w', encoding='utf-8') as f:
        json.dump(tasks, f, ensure_ascii=False, indent=4)

@app.on_callback_query(filters.regex(r"^flooder_chats$"))
async def flooder_chats_handler(client: Client, callback_query: CallbackQuery):
    await callback_query.message.delete()
    await show_chats_menu(callback_query.message)
    await callback_query.answer()

async def stop_flooder_task(chat_id: str, task_id: str):
    task_key = f"{chat_id}_{task_id}"
    if task_key in active_tasks:
        active_tasks[task_key].cancel()
        del active_tasks[task_key]
        print(f"‚úÖ –ó–∞–¥–∞—á–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: {task_key}")

async def run_flooder_task(chat_id: str, task_id: str, task_data: Dict):
    task_key = f"{chat_id}_{task_id}"
    
    if task_key in active_tasks:
        active_tasks[task_key].cancel()
    
    async def flooder_loop():
        try:
            text_file_path = f"config/{task_data['text_file']}"
            if os.path.exists(text_file_path):
                async with aiofiles.open(text_file_path, 'r', encoding='utf-8') as f:
                    content = await f.read()
                    messages = [msg.strip() for msg in content.split('\n') if msg.strip()]
            else:
                print(f"‚ùå –§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {text_file_path}")
                return
            
            media_file_path = f"config/{task_data['media_file']}" if task_data['media_file'] else None
            
            while True:
                flooder_tasks = load_flooder_tasks()
                current_task = flooder_tasks.get(chat_id, {}).get(task_id)
                
                if not current_task or not current_task.get('active', True):
                    print(f"‚ùå –ó–∞–¥–∞—á–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: {task_key}")
                    break
                
                message_text = task_data['prefix'] + ' ' + random.choice(messages) if task_data['prefix'] else random.choice(messages)
                
                try:
                    if task_data['media_file'] and media_file_path and os.path.exists(media_file_path):
                        if task_data['media_file'].lower().endswith(('.jpg', '.jpeg', '.png', '.gif')):
                            await app.send_photo(chat_id, media_file_path, caption=message_text)
                        elif task_data['media_file'].lower().endswith(('.mp4', '.avi', '.mov', '.mkv')):
                            await app.send_video(chat_id, media_file_path, caption=message_text)
                        else:
                            await app.send_document(chat_id, media_file_path, caption=message_text)
                    else:
                        await app.send_message(chat_id, message_text)
                    
                    await asyncio.sleep(task_data['delay'])
                    
                except Exception as e:
                    print(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {e}")
                    await asyncio.sleep(10)
                    
        except asyncio.CancelledError:
            print(f"‚úÖ –ó–∞–¥–∞—á–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞: {task_key}")
            raise
        except Exception as e:
            print(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
            await asyncio.sleep(5)
            if task_key in active_tasks:
                active_tasks[task_key] = asyncio.create_task(flooder_loop())
    
    active_tasks[task_key] = asyncio.create_task(flooder_loop())
    print(f"‚úÖ –ó–∞–¥–∞—á–∞ –∑–∞–ø—É—â–µ–Ω–∞: {task_key}")

async def start_all_flooder_tasks():
    flooder_tasks = load_flooder_tasks()
    for chat_id, tasks in flooder_tasks.items():
        for task_id, task_data in tasks.items():
            if task_data.get('active', True):
                await run_flooder_task(chat_id, task_id, task_data)

@lru_cache(maxsize=100)
def load_chats() -> Dict:
    os.makedirs('config', exist_ok=True)
    if os.path.exists('config/chats.json'):
        try:
            with open('config/chats.json', 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}
    return {}

def save_chats(chats_data: Dict):
    os.makedirs('config', exist_ok=True)
    with open('config/chats.json', 'w', encoding='utf-8') as f:
        json.dump(chats_data, f, ensure_ascii=False, indent=4)

@app.on_message(filters.group & filters.new_chat_members)
async def on_bot_added_to_group(client: Client, message: Message):
    me = await client.get_me()
    for new_member in message.new_chat_members:
        if new_member.id == me.id:
            chat = message.chat
            chats_data = load_chats()
            chats_data[str(chat.id)] = {
                'title': chat.title,
                'type': str(chat.type),
                'username': chat.username,
                'added_date': message.date.isoformat(),
                'is_active': True
            }
            save_chats(chats_data)

@app.on_message(filters.group & filters.left_chat_member)
async def on_bot_removed_from_group(client: Client, message: Message):
    me = await client.get_me()
    if message.left_chat_member and message.left_chat_member.id == me.id:
        chat = message.chat
        chats_data = load_chats()
        if str(chat.id) in chats_data:
            chats_data[str(chat.id)]['is_active'] = False
            save_chats(chats_data)

@app.on_message(filters.group)
async def optimized_group_handler(client: Client, message: Message):
    try:
        chat = message.chat
        chats_data = load_chats()
        chat_key = str(chat.id)
        
        if chat_key not in chats_data or chats_data[chat_key]['title'] != chat.title:
            chats_data[chat_key] = {
                'title': chat.title,
                'type': str(chat.type),
                'username': chat.username,
                'added_date': message.date.isoformat(),
                'is_active': True
            }
            save_chats(chats_data)
        
        targets = load_respond_targets()
        if not targets:
            return
        
        chat_id_str = chat_key
        user_id_str = str(message.from_user.id)
        
        if chat_id_str in targets or user_id_str in targets:
            phrases_content = await async_cached_read('Phrases/messages.txt')
            if phrases_content:
                phrases = [line.strip() for line in phrases_content.split('\n') if line.strip()]
                if phrases:
                    response_text = random.choice(phrases)
                    asyncio.create_task(message.reply(response_text))
                    
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: {e}")

async def show_chats_menu(message: Message, page: int = 0):
    chats_data = load_chats()
    if not chats_data:
        await message.reply("üìã –ù–µ—Ç —á–∞—Ç–æ–≤")
        return
    
    active_chats = {chat_id: info for chat_id, info in chats_data.items() if info.get('is_active', True)}
    if not active_chats:
        await message.reply("üìã –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —á–∞—Ç–æ–≤")
        return
    
    sorted_chats = sorted(active_chats.items(), key=lambda x: x[1]['title'])
    items_per_page = 5
    total_pages = math.ceil(len(sorted_chats) / items_per_page)
    
    if page >= total_pages: page = total_pages - 1
    if page < 0: page = 0
    
    start_idx = page * items_per_page
    end_idx = start_idx + items_per_page
    current_chats = sorted_chats[start_idx:end_idx]
    
    keyboard = []
    for chat_id, chat_info in current_chats:
        chat_title = chat_info['title'][:30] + "..." if len(chat_info['title']) > 30 else chat_info['title']
        keyboard.append([InlineKeyboardButton(chat_title, callback_data=f"chat_select|{chat_id}|{page}")])
    
    pagination_buttons = []
    if page > 0:
        pagination_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"chat_page|{page-1}"))
    if page < total_pages - 1:
        pagination_buttons.append(InlineKeyboardButton("–í–ø–µ—Ä–µ–¥ ‚û°Ô∏è", callback_data=f"chat_page|{page+1}"))
    
    if pagination_buttons:
        keyboard.append(pagination_buttons)
    
    keyboard.append([InlineKeyboardButton("üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data=f"chat_refresh|{page}")])
    
    await message.reply(
        f"üìã –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —á–∞—Ç–∞–º–∏ (–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page + 1}/{total_pages})\n\n–í—ã–±–µ—Ä–∏—Ç–µ —á–∞—Ç:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

@app.on_message(filters.command("chats"))
async def chats_command(client: Client, message: Message):
    await show_chats_menu(message)

@app.on_callback_query(filters.regex(r"^chat_page\|"))
async def chats_pagination_handler(client: Client, callback_query: CallbackQuery):
    page = int(callback_query.data.split('|')[1])
    await callback_query.message.delete()
    await show_chats_menu(callback_query.message, page)
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^chat_refresh\|"))
async def chats_refresh_handler(client: Client, callback_query: CallbackQuery):
    page = int(callback_query.data.split('|')[1])
    await callback_query.message.delete()
    await show_chats_menu(callback_query.message, page)
    await callback_query.answer("‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω–æ")

@app.on_callback_query(filters.regex(r"^chat_select\|"))
async def chat_select_handler(client: Client, callback_query: CallbackQuery):
    data_parts = callback_query.data.split('|')
    chat_id = data_parts[1]
    page = int(data_parts[2])
    
    chats_data = load_chats()
    chat_info = chats_data.get(chat_id)
    if not chat_info:
        await callback_query.answer("‚ùå –ß–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    
    flooder_tasks = load_flooder_tasks()
    chat_tasks = flooder_tasks.get(chat_id, {})
    
    tasks_text = "üìã –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞—á–∏:\n"
    if chat_tasks:
        for task_id, task_data in chat_tasks.items():
            status = "‚úÖ –í–ö–õ" if task_data.get('active', True) else "‚ùå –í–´–ö–õ"
            tasks_text += f"\nüîπ {task_id}: {status} ({task_data['delay']}—Å–µ–∫)"
    else:
        tasks_text += "\n‚ùå –ù–µ—Ç –∑–∞–¥–∞—á"
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ûï –°–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞–Ω–∏–µ", callback_data=f"create_task|{chat_id}")],
        [InlineKeyboardButton("‚öôÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data=f"edit_tasks|{chat_id}|{page}")],
        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=f"back_to_chats|{page}")]
    ])
    
    await callback_query.message.edit_text(
        f"üí¨ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —á–∞—Ç–æ–º: {chat_info['title']}\n\n{tasks_text}\n\nüìç ID: {chat_id}",
        reply_markup=keyboard
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^create_task\|"))
async def create_task_step1(client: Client, callback_query: CallbackQuery):
    chat_id = callback_query.data.split('|')[1]
    
    user_data_storage[callback_query.from_user.id] = {
        'state': "waiting_delay",
        'chat_id': chat_id
    }
    
    await callback_query.message.edit_text(
        "‚è∞ –í–≤–µ–¥–∏—Ç–µ –∑–∞–¥–µ—Ä–∂–∫—É –≤ —Å–µ–∫—É–Ω–¥–∞—Ö:",
        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_task")]])
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^cancel_task"))
async def cancel_task(client: Client, callback_query: CallbackQuery):
    if callback_query.from_user.id in user_data_storage:
        del user_data_storage[callback_query.from_user.id]
    await callback_query.message.edit_text("‚ùå –û—Ç–º–µ–Ω–µ–Ω–æ")
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^back_to_chats\|"))
async def back_to_chats_handler(client: Client, callback_query: CallbackQuery):
    page = int(callback_query.data.split('|')[1])
    await callback_query.message.delete()
    await show_chats_menu(callback_query.message, page)
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^textfile\|"))
async def create_task_step4(client: Client, callback_query: CallbackQuery):
    if callback_query.from_user.id not in user_data_storage:
        await callback_query.answer("‚ùå –°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞")
        return
        
    text_file = callback_query.data.split('|', 1)[1]
    user_data = user_data_storage[callback_query.from_user.id]
    user_data['text_file'] = text_file
    user_data['state'] = "waiting_media_file"
    user_data_storage[callback_query.from_user.id] = user_data
    
    media_files = []
    if os.path.exists('config'):
        for file in os.listdir('config'):
            if file.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.mp4', '.avi', '.mov', '.mkv')):
                media_files.append(file)
    
    keyboard = [
        [InlineKeyboardButton("üö´ –ë–µ–∑ –º–µ–¥–∏–∞", callback_data="media|none")]
    ]
    
    for file in media_files:
        keyboard.append([InlineKeyboardButton(f"üìÅ {file}", callback_data=f"media|{file}")])
    
    keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_task")])
    
    await callback_query.message.edit_text("üé¨ –í—ã–±–µ—Ä–∏—Ç–µ –º–µ–¥–∏–∞:", reply_markup=InlineKeyboardMarkup(keyboard))
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^media\|"))
async def create_task_final(client: Client, callback_query: CallbackQuery):
    if callback_query.from_user.id not in user_data_storage:
        await callback_query.answer("‚ùå –°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞")
        return
        
    media_data = callback_query.data.split('|', 1)[1]
    media_file = None if media_data == 'none' else media_data
    
    user_data = user_data_storage[callback_query.from_user.id]
    
    task_id = f"task_{int(time.time())}"
    flooder_tasks = load_flooder_tasks()
    chat_id = user_data['chat_id']
    
    if chat_id not in flooder_tasks:
        flooder_tasks[chat_id] = {}
    
    flooder_tasks[chat_id][task_id] = {
        'delay': user_data['delay'],
        'prefix': user_data['prefix'],
        'text_file': user_data['text_file'],
        'media_file': media_file,
        'active': True
    }
    
    save_flooder_tasks(flooder_tasks)
    await run_flooder_task(chat_id, task_id, flooder_tasks[chat_id][task_id])
    
    del user_data_storage[callback_query.from_user.id]
    
    await callback_query.message.edit_text(
        f"‚úÖ –ó–∞–¥–∞—á–∞ —Å–æ–∑–¥–∞–Ω–∞!\n\nID: {task_id}\n–ó–∞–¥–µ—Ä–∂–∫–∞: {user_data['delay']}—Å–µ–∫\n"
        f"–ü—Ä–µ—Ñ–∏–∫—Å: {user_data['prefix'] or '–ù–µ—Ç'}\n–§–∞–π–ª: {user_data['text_file']}\n"
        f"–ú–µ–¥–∏–∞: {media_file or '–ù–µ—Ç'}",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data=f"chat_select|{chat_id}|0")]
        ])
    )
    await callback_query.answer()

# –û—Å—Ç–∞–ª—å–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ callback (edit_tasks, task_manage, task_toggle, task_delay_edit, task_prefix_edit, 
# task_textfile, edit_textfile, task_media, edit_media, task_delete, confirm_delete) –æ—Å—Ç–∞—é—Ç—Å—è –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–º–∏
# –Ω–æ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π –∏ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è

# –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –º—É–ª—å—Ç–∏-—Å–ø–∞–º–∞
@app.on_callback_query(filters.regex(r"^multi_add_token$"))
async def multi_add_token_handler(client: Client, callback_query: CallbackQuery):
    user_id = callback_query.from_user.id
    user_data_storage[user_id] = {'state': "waiting_multi_tokens"}
    
    await callback_query.message.edit_text(
        "üîë –ü—Ä–∏—à–ª–∏—Ç–µ —Ç–æ–∫–µ–Ω—ã –±–æ—Ç–æ–≤ (–∫–∞–∂–¥—ã–π —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏):",
        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="multi_cancel")]])
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^multi_list_tokens$"))
async def multi_list_tokens_handler(client: Client, callback_query: CallbackQuery):
    tokens = load_tokens()
    if not tokens:
        await callback_query.answer("‚ùå –ù–µ—Ç —Ç–æ–∫–µ–Ω–æ–≤")
        return
    
    tokens_text = "üîë –°–ø–∏—Å–æ–∫ —Ç–æ–∫–µ–Ω–æ–≤:\n\n"
    for i, token in enumerate(tokens, 1):
        tokens_text += f"{i}. {token[:10]}...{token[-10:]}\n"
    
    await callback_query.message.edit_text(
        tokens_text,
        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="multi_back_to_main")]])
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^multi_add$"))
async def multi_add_handler(client: Client, callback_query: CallbackQuery):
    await callback_query.message.delete()
    await show_multi_chats_menu(callback_query.message)
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^multi_chat_page\|"))
async def multi_chat_page_handler(client: Client, callback_query: CallbackQuery):
    page = int(callback_query.data.split('|')[1])
    await callback_query.message.delete()
    await show_multi_chats_menu(callback_query.message, page)
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^multi_chat_select\|"))
async def multi_chat_select_handler(client: Client, callback_query: CallbackQuery):
    data_parts = callback_query.data.split('|')
    chat_id = data_parts[1]
    page = int(data_parts[2])
    
    chats_data = load_chats()
    chat_info = chats_data.get(chat_id)
    
    if not chat_info:
        await callback_query.answer("‚ùå –ß–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
        return
    
    user_id = callback_query.from_user.id
    user_data_storage[user_id] = {
        'state': "waiting_multi_delay",
        'chat_id': chat_id,
        'page': page
    }
    
    await callback_query.message.edit_text(
        f"‚è∞ –í–≤–µ–¥–∏—Ç–µ –∑–∞–¥–µ—Ä–∂–∫—É –≤ —Å–µ–∫—É–Ω–¥–∞—Ö –¥–ª—è —á–∞—Ç–∞ {chat_info['title']}:",
        reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="multi_cancel")]])
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^show_respond_targets$"))
async def show_respond_targets_handler(client: Client, callback_query: CallbackQuery):
    targets = load_respond_targets()
    
    if not targets:
        await callback_query.message.edit_text("üìä –°–ø–∏—Å–æ–∫ —Ü–µ–ª–µ–π –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫–∞ –ø—É—Å—Ç")
        await callback_query.answer()
        return
    
    targets_text = "üìä –¶–µ–ª–∏ –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫–∞:\n\n"
    for target_id, target_info in targets.items():
        name = target_info.get('name', f'–¶–µ–ª—å {target_id}')
        targets_text += f"‚Ä¢ {name} (ID: {target_id})\n"
    
    await callback_query.message.edit_text(
        targets_text,
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_respond_menu")]
        ])
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^back_to_respond_menu$"))
async def back_to_respond_menu_handler(client: Client, callback_query: CallbackQuery):
    targets = load_respond_targets()
    targets_count = len(targets)
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üìã –î–æ–±–∞–≤–∏—Ç—å —Ü–µ–ª—å", callback_data="add_respond"),
         InlineKeyboardButton('‚ùå –£–¥–∞–ª–∏—Ç—å —Ü–µ–ª—å', callback_data='delete_respond')],
        [InlineKeyboardButton("üìä –ü–æ–∫–∞–∑–∞—Ç—å —Ü–µ–ª–∏", callback_data="show_respond_targets")]
    ])
    
    await callback_query.message.edit_text(
        f"üåò –ê–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫ - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ\n\nüìä –ê–∫—Ç–∏–≤–Ω—ã—Ö —Ü–µ–ª–µ–π: {targets_count}\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=keyboard
    )
    await callback_query.answer()

# –ö—ç—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —á—Ç–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤
@lru_cache(maxsize=100)
def cached_read_file(file_path: str):
    if os.path.exists(file_path):
        with open(file_path, 'r', encoding='utf-8') as f:
            return f.read()
    return ""

async def async_cached_read(file_path: str):
    loop = asyncio.get_event_loop()
    return await loop.run_in_executor(None, cached_read_file, file_path)

# –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–¥–∞—á
async def task_monitor():
    while True:
        try:
            await asyncio.sleep(30)
            
            multi_tasks = load_multi_tasks()
            for chat_id, task_data in multi_tasks.items():
                task_key = f"multi_{chat_id}"
                if task_data.get('active', True) and task_key not in active_tasks:
                    print(f"üîÑ –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–¥–∞—á—É: {task_key}")
                    await run_multi_task_optimized(chat_id, task_data)
            
            flooder_tasks = load_flooder_tasks()
            for chat_id, tasks in flooder_tasks.items():
                for task_id, task_data in tasks.items():
                    task_key = f"{chat_id}_{task_id}"
                    if task_data.get('active', True) and task_key not in active_tasks:
                        print(f"üîÑ –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–¥–∞—á—É: {task_key}")
                        await run_flooder_task(chat_id, task_id, task_data)
                        
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∞: {e}")
            await asyncio.sleep(60)

# –û–ë–ù–û–í–õ–ï–ù–ù–´–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö –¢–ï–ö–°–¢–û–í–´–• –°–û–û–ë–©–ï–ù–ò–ô
@app.on_message(filters.all & filters.private & filters.text & ~filters.command("start") & ~filters.command("chats"))
async def handle_all_text_messages(client: Client, message: Message):
    user_id = message.from_user.id
    
    if user_id in user_data_storage:
        user_data = user_data_storage[user_id]
        state = user_data.get('state')
        
        if state == "waiting_edit_delay":
            try:
                delay = int(message.text)
                if delay < 1:
                    await message.reply("‚ùå –ú–∏–Ω–∏–º—É–º 1 —Å–µ–∫—É–Ω–¥–∞")
                    return
                
                flooder_tasks = load_flooder_tasks()
                chat_id = user_data['chat_id']
                task_id = user_data['task_id']
                
                if chat_id in flooder_tasks and task_id in flooder_tasks[chat_id]:
                    await stop_flooder_task(chat_id, task_id)
                    
                    flooder_tasks[chat_id][task_id]['delay'] = delay
                    save_flooder_tasks(flooder_tasks)
                    
                    if flooder_tasks[chat_id][task_id].get('active', True):
                        await run_flooder_task(chat_id, task_id, flooder_tasks[chat_id][task_id])
                    
                    await message.reply("‚úÖ –ó–∞–¥–µ—Ä–∂–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∞")
                    del user_data_storage[user_id]
                    
                    callback_data = f"task_manage|{chat_id}|{task_id}|{user_data['page']}"
                    callback_query = type('obj', (object,), {
                        'data': callback_data,
                        'message': message,
                        'from_user': message.from_user
                    })()
                    await task_manage_handler(client, callback_query)
                else:
                    await message.reply("‚ùå –ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
                    del user_data_storage[user_id]
                    
            except ValueError:
                await message.reply("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ")
        
        elif state == "waiting_edit_prefix":
            prefix = message.text if message.text.lower() != '–Ω–µ—Ç' else ''
            
            flooder_tasks = load_flooder_tasks()
            chat_id = user_data['chat_id']
            task_id = user_data['task_id']
            
            if chat_id in flooder_tasks and task_id in flooder_tasks[chat_id]:
                await stop_flooder_task(chat_id, task_id)
                
                flooder_tasks[chat_id][task_id]['prefix'] = prefix
                save_flooder_tasks(flooder_tasks)
                
                if flooder_tasks[chat_id][task_id].get('active', True):
                    await run_flooder_task(chat_id, task_id, flooder_tasks[chat_id][task_id])
                
                await message.reply("‚úÖ –ü—Ä–µ—Ñ–∏–∫—Å –∏–∑–º–µ–Ω–µ–Ω")
                del user_data_storage[user_id]
                
                callback_data = f"task_manage|{chat_id}|{task_id}|{user_data['page']}"
                callback_query = type('obj', (object,), {
                    'data': callback_data,
                    'message': message,
                    'from_user': message.from_user
                })()
                await task_manage_handler(client, callback_query)
            else:
                await message.reply("‚ùå –ó–∞–¥–∞—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
                del user_data_storage[user_id]
        
        elif state == "waiting_delay":
            try:
                delay = int(message.text)
                if delay < 1:
                    await message.reply("‚ùå –ú–∏–Ω–∏–º—É–º 1 —Å–µ–∫—É–Ω–¥–∞")
                    return
                    
                user_data['delay'] = delay
                user_data['state'] = "waiting_prefix"
                user_data_storage[user_id] = user_data
                
                await message.reply(
                    "üìù –í–≤–µ–¥–∏—Ç–µ –ø—Ä–µ—Ñ–∏–∫—Å (–∏–ª–∏ '–ù–µ—Ç'):",
                    reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_task")]])
                )
                
            except ValueError:
                await message.reply("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ")

        elif state == "waiting_add_respond_target":
             try:
                 target_id = message.text.strip()
                 targets = load_respond_targets()
                 
                 if target_id in targets:
                     await message.reply("‚ùå –≠—Ç–æ—Ç ID —É–∂–µ –µ—Å—Ç—å –≤ —Å–ø–∏—Å–∫–µ –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫–∞")
                 else:
                     targets[target_id] = {
                         'name': f'–¶–µ–ª—å {target_id}',
                         'added_date': time.time(),
                         'added_by': user_id
                     }
                     save_respond_targets(targets)
                     await message.reply(f"‚úÖ –¶–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω–∞: ID {target_id}")
                 
                 del user_data_storage[user_id]
                 
             except Exception as e:
                 await message.reply(f"‚ùå –û—à–∏–±–∫–∞: {e}")
                 del user_data_storage[user_id]

        elif state == "waiting_delete_respond_target":
            try:
                target_id = message.text.strip()
                targets = load_respond_targets()
                
                if target_id in targets:
                    del targets[target_id]
                    save_respond_targets(targets)
                    await message.reply(f"‚úÖ –¶–µ–ª—å —É–¥–∞–ª–µ–Ω–∞: ID {target_id}")
                else:
                    await message.reply("‚ùå –≠—Ç–æ—Ç ID –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–ø–∏—Å–∫–µ –∞–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫–∞")
                
                del user_data_storage[user_id]
                
            except Exception as e:
                 await message.reply(f"‚ùå –û—à–∏–±–∫–∞: {e}")
                 del user_data_storage[user_id]       
        
        elif state == "waiting_prefix":
            prefix = message.text if message.text.lower() != '–Ω–µ—Ç' else ''
            user_data['prefix'] = prefix
            user_data['state'] = "waiting_text_file"
            user_data_storage[user_id] = user_data
            
            txt_files = []
            if os.path.exists('config'):
                for file in os.listdir('config'):
                    if file.endswith('.txt'):
                        txt_files.append(file)
            
            if not txt_files:
                await message.reply("‚ùå –ù–µ—Ç txt —Ñ–∞–π–ª–æ–≤")
                del user_data_storage[user_id]
                return
            
            keyboard = []
            for file in txt_files:
                keyboard.append([InlineKeyboardButton(f"üìÑ {file}", callback_data=f"textfile|{file}")])
            
            keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_task")])
            
            await message.reply("üìÅ –í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª:", reply_markup=InlineKeyboardMarkup(keyboard))
        elif state == "waiting_multi_tokens":
             tokens = load_tokens()
             new_tokens = [token.strip() for token in message.text.split('\n') if token.strip()]
             
             added_count = 0
             for token in new_tokens:
                 if token not in tokens:
                     tokens.append(token)
                     added_count += 1
             
             save_tokens(tokens)
             await message.reply(f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ {added_count} –Ω–æ–≤—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤. –í—Å–µ–≥–æ: {len(tokens)}")
             del user_data_storage[user_id]
        
        elif state == "waiting_admin_id":
            try:
                new_admin_id = message.text.strip()
                
                if not new_admin_id.isdigit():
                    await message.reply("‚ùå ID –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ü–∏—Ñ—Ä—ã")
                    return
                
                admins_file = 'config/admins.json'
                if os.path.exists(admins_file):
                    with open(admins_file, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                else:
                    data = {"admins": []}
                
                if new_admin_id in data["admins"]:
                    await message.reply("‚ùå –≠—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º")
                    del user_data_storage[user_id]
                    return
                
                data["admins"].append(new_admin_id)
                
                with open(admins_file, 'w', encoding='utf-8') as f:
                    json.dump(data, f, ensure_ascii=False, indent=4)
                
                await message.reply(f"‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {new_admin_id} –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã")
                del user_data_storage[user_id]
                
            except Exception as e:
                await message.reply(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞: {e}")
                if user_id in user_data_storage:
                    del user_data_storage[user_id]

        elif state == "waiting_multi_delay":
            try:
                delay = int(message.text)
                if delay < 1:
                    await message.reply("‚ùå –ú–∏–Ω–∏–º—É–º 1 —Å–µ–∫—É–Ω–¥–∞")
                    return
                    
                user_data = user_data_storage[user_id]
                user_data['delay'] = delay
                user_data['state'] = "waiting_multi_prefix"
                user_data_storage[user_id] = user_data
                
                await message.reply("üìù –í–≤–µ–¥–∏—Ç–µ –ø—Ä–µ—Ñ–∏–∫—Å (–∏–ª–∏ '–ù–µ—Ç'):")
                
            except ValueError:
                await message.reply("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ")
        
        elif state == "waiting_multi_prefix":
              prefix = message.text if message.text.lower() != '–Ω–µ—Ç' else ''
              user_data = user_data_storage[user_id]
              user_data['prefix'] = prefix
              user_data['state'] = "waiting_multi_text_file"
              user_data_storage[user_id] = user_data
              
              # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–ø–∏—Å–æ–∫ txt —Ñ–∞–π–ª–æ–≤
              txt_files = []
              if os.path.exists('config'):
                  for file in os.listdir('config'):
                      if file.endswith('.txt'):
                          txt_files.append(file)
              
              if not txt_files:
                  await message.reply("‚ùå –ù–µ—Ç txt —Ñ–∞–π–ª–æ–≤")
                  del user_data_storage[user_id]
                  return
              
              keyboard = []
              for file in txt_files:
                  keyboard.append([InlineKeyboardButton(f"üìÑ {file}", callback_data=f"multi_textfile|{file}")])
              
              keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="multi_cancel")])
              
              await message.reply("üìÅ –í—ã–±–µ—Ä–∏—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª:", reply_markup=InlineKeyboardMarkup(keyboard))
        
        else:
            del user_data_storage[user_id]
            await handle_main_menu(client, message)
    else:
        await handle_main_menu(client, message)










@app.on_callback_query(filters.regex(r"^add_admin$"))
async def add_admin_handler(client: Client, callback_query: CallbackQuery):
    """–ù–∞—á–∏–Ω–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∞"""
    user_id = callback_query.from_user.id
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    is_admin = await chek_admin(user_id)
    if not is_admin:
        await callback_query.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞")
        return
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∞
    user_data_storage[user_id] = {
        'state': "waiting_admin_id"
    }
    
    await callback_query.message.edit_text(
        "üëë –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞\n\n"
        "–í–≤–µ–¥–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫–æ—Ç–æ—Ä–æ–≥–æ —Ö–æ—Ç–∏—Ç–µ —Å–¥–µ–ª–∞—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º:",
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_add_admin")]
        ])
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^cancel_add_admin$"))
async def cancel_add_admin_handler(client: Client, callback_query: CallbackQuery):
    """–û—Ç–º–µ–Ω–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∞"""
    user_id = callback_query.from_user.id
    if user_id in user_data_storage:
        del user_data_storage[user_id]
    
    await callback_query.message.edit_text("‚ùå –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ")
    await callback_query.answer()



@app.on_callback_query(filters.regex(r"^remove_admin$"))
async def remove_admin_handler(client: Client, callback_query: CallbackQuery):
    """–ù–∞—á–∏–Ω–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å —É–¥–∞–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∞"""
    user_id = callback_query.from_user.id
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    is_admin = await chek_admin(user_id)
    if not is_admin:
        await callback_query.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞")
        return
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–ø–∏—Å–æ–∫ –∞–¥–º–∏–Ω–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
    admins_file = 'config/admins.json'
    if os.path.exists(admins_file):
        with open(admins_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
        admins_list = data["admins"]
    else:
        admins_list = []
    
    if not admins_list:
        await callback_query.answer("‚ùå –ù–µ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è")
        return
    
    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∞–¥–º–∏–Ω–∞–º–∏ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
    keyboard = []
    for admin_id in admins_list:
        keyboard.append([InlineKeyboardButton(f"‚ùå –£–¥–∞–ª–∏—Ç—å {admin_id}", callback_data=f"remove_admin_confirm|{admin_id}")])
    
    keyboard.append([InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_remove_admin")])
    
    await callback_query.message.edit_text(
        "üëë –£–¥–∞–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^remove_admin_confirm\|"))
async def remove_admin_confirm_handler(client: Client, callback_query: CallbackQuery):
    """–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∞"""
    admin_id_to_remove = callback_query.data.split('|')[1]
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚úÖ –î–∞, —É–¥–∞–ª–∏—Ç—å", callback_data=f"remove_admin_final|{admin_id_to_remove}")],
        [InlineKeyboardButton("‚ùå –ù–µ—Ç, –æ—Ç–º–µ–Ω–∞", callback_data="remove_admin")]
    ])
    
    await callback_query.message.edit_text(
        f"‚ö†Ô∏è –í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ {admin_id_to_remove}?",
        reply_markup=keyboard
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex(r"^remove_admin_final\|"))
async def remove_admin_final_handler(client: Client, callback_query: CallbackQuery):
    """–§–∏–Ω–∞–ª—å–Ω–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∞"""
    admin_id_to_remove = callback_query.data.split('|')[1]
    
    try:
        # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫ –∞–¥–º–∏–Ω–æ–≤
        admins_file = 'config/admins.json'
        if os.path.exists(admins_file):
            with open(admins_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # –£–¥–∞–ª—è–µ–º –∞–¥–º–∏–Ω–∞
            if admin_id_to_remove in data["admins"]:
                data["admins"].remove(admin_id_to_remove)
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫
                with open(admins_file, 'w', encoding='utf-8') as f:
                    json.dump(data, f, ensure_ascii=False, indent=4)
                
                await callback_query.answer(f"‚úÖ –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä {admin_id_to_remove} —É–¥–∞–ª–µ–Ω")
            else:
                await callback_query.answer("‚ùå –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω")
        else:
            await callback_query.answer("‚ùå –§–∞–π–ª –∞–¥–º–∏–Ω–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω")
    
    except Exception as e:
        await callback_query.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏: {e}")
    
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Å–ø–∏—Å–∫—É –∞–¥–º–∏–Ω–æ–≤
    callback_query.data = "remove_admin"
    await remove_admin_handler(client, callback_query)


@app.on_message(filters.private & (filters.photo | filters.document | filters.video | filters.audio))
async def save_media_to_config(client: Client, message: Message):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –º–µ–¥–∏–∞—Ñ–∞–π–ª—ã –≤ –ø–∞–ø–∫—É config"""
    result = await chek_admin(message.from_user.id)
    if not result:
        await message.reply("‚ùå –ù–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–æ–≤")
        return
    
    try:
        # –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É config –µ—Å–ª–∏ –Ω–µ—Ç
        os.makedirs('config', exist_ok=True)
        
        if message.photo:
            # –§–æ—Ç–æ
            file_name = f"photo_{message.id}.jpg"
            file_path = f"config/{file_name}"
            await message.download(file_name=file_path)
            await message.reply(f"‚úÖ –§–æ—Ç–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {file_name}")
            
        elif message.document:
            # –î–æ–∫—É–º–µ–Ω—Ç—ã
            file_name = message.document.file_name or f"document_{message.id}"
            file_path = f"config/{file_name}"
            await message.download(file_name=file_path)
            await message.reply(f"‚úÖ –î–æ–∫—É–º–µ–Ω—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω: {file_name}")
            
        elif message.video:
            # –í–∏–¥–µ–æ
            file_name = message.video.file_name or f"video_{message.id}.mp4"
            file_path = f"config/{file_name}"
            await message.download(file_name=file_path)
            await message.reply(f"‚úÖ –í–∏–¥–µ–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {file_name}")
            
        elif message.audio:
            # –ê—É–¥–∏–æ
            file_name = message.audio.file_name or f"audio_{message.id}.mp3"
            file_path = f"config/{file_name}"
            await message.download(file_name=file_path)
            await message.reply(f"‚úÖ –ê—É–¥–∏–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {file_name}")
            
    except Exception as e:
        await message.reply(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {e}")
        print(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–∞–π–ª–∞: {e}")


async def main_optimized():
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è aiohttp —Å–µ—Å—Å–∏–∏
    await create_aiohttp_session()
    
    await app.start()
    print("‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω")
    
    asyncio.create_task(task_monitor())
    
    await start_all_flooder_tasks()
    print("‚úÖ –ó–∞–¥–∞—á–∏ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã")
    
    multi_tasks = load_multi_tasks()
    for chat_id, task_data in multi_tasks.items():
        if task_data.get('active', True):
            await run_multi_task_optimized(chat_id, task_data)
    
    print("‚úÖ –ú—É–ª—å—Ç–∏-–∑–∞–¥–∞—á–∏ –∑–∞–ø—É—â–µ–Ω—ã")
    
    try:
        await idle()
    finally:
        # –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ
        await close_aiohttp_session()
        
        # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ –∑–∞–¥–∞—á–∏
        for task in active_tasks.values():
            task.cancel()
        
        await asyncio.gather(*active_tasks.values(), return_exceptions=True)
        thread_pool.shutdown(wait=True)
        print("‚úÖ –†–µ—Å—É—Ä—Å—ã –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω—ã")


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    
    try:
        app.run(main_optimized())
    except KeyboardInterrupt:
        print("üëã –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ")
    except Exception as e:
        print(f"üí• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
        os.execv(sys.executable, [sys.executable] + sys.argv)










